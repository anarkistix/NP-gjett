<!doctype html>
<html lang="no">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
    <title>Nasjonalpark-spill</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" crossorigin="anonymous" />
    <style>
      html, body { height: 100%; margin: 0; background:#fff; }
      body { font: 14px system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif; }
      #map { position: absolute; inset: 0; }
      .hud { position:absolute; top:8px; left:8px; z-index:900; background:rgba(255,255,255,0.92); border:1px solid #ddd; border-radius:6px; padding:6px 8px; font-size:12px; }
      .topbar { position:absolute; top:8px; right:8px; z-index:900; display:flex; gap:6px; }
      .btn { background:#0a7a62; color:#fff; border:none; border-radius:6px; padding:8px 10px; font-size:14px; }
      .btn:active { transform: scale(0.98); }
      #hint { position:absolute; top:48px; left:8px; right:8px; z-index:900; display:flex; flex-direction:column; gap:6px; max-height:38vh; overflow:auto; }
      .hintItem { background:#111; color:#00ff88; border:2px solid #00ff88; border-radius:6px; padding:8px 10px; font: bold 13px monospace; letter-spacing:1px; text-shadow:0 0 2px #00ff88; }
      .scorebar { position:absolute; top:8px; right:8px; z-index:905; display:flex; gap:6px; }
      .score, .timer { background:#111; color:#00ff88; border:2px solid #00ff88; border-radius:6px; padding:6px 8px; font: bold 13px monospace; letter-spacing:1px; text-shadow:0 0 2px #00ff88; }
      #guessBar { position:absolute; bottom:0; left:0; right:0; z-index:900; background:rgba(255,255,255,0.98); border-top:1px solid #ddd; padding:10px 12px calc(10px + env(safe-area-inset-bottom)); }
      #choices { display:grid; grid-template-columns: 1fr 1fr; gap:8px; }
      .choiceBtn { background:#111; color:#00ff88; border:2px solid #00ff88; border-radius:6px; padding:10px 12px; font: bold 13px monospace; letter-spacing:1px; text-shadow:0 0 2px #00ff88; }
      .choiceBtn:active { transform: scale(0.98); }
      .choiceBtn.correct { background:#111; border-color:#00ff88; color:#00ff88; text-shadow:0 0 3px #00ff88; }
      .choiceBtn.wrong { background:#111; border-color:#ff6b6b; color:#ff6b6b; text-shadow:0 0 2px #ff6b6b; }
      .choiceBtn:disabled:not(.wrong):not(.correct), .choiceBtn.disabled:not(.wrong):not(.correct) { background:#e9e9e9; color:#9a9a9a; border-color:#c8c8c8; text-shadow:none; }
      .choiceBtn.wrong:disabled, .choiceBtn.wrong.disabled { background:#111; border-color:#ff6b6b; color:#ff6b6b; text-shadow:0 0 2px #ff6b6b; }
      #winOverlay { position:absolute; inset:0; z-index:1000; display:none; align-items:center; justify-content:center; background:rgba(0,0,0,0.5); }
      .winContent { background:#111; border:2px solid #00ff88; border-radius:10px; padding:20px 24px; text-align:center; color:#00ff88; font: bold 28px monospace; letter-spacing:2px; text-shadow:0 0 3px #00ff88; }
      .winContent .btn { margin-top:12px; font-size:16px; }
      #correctOverlay { position:absolute; inset:0; z-index:1100; display:none; align-items:center; justify-content:center; pointer-events:none; }
      #correctOverlay .msg { background:#111; color:#00ff88; border:2px solid #00ff88; border-radius:10px; padding:16px 20px; font: bold 36px monospace; letter-spacing:2px; text-shadow:0 0 3px #00ff88; text-align:center; }
      #correctOverlay .msg .sub { margin-top:8px; font: bold 18px monospace; letter-spacing:1px; }
      #wrongOverlay { position:absolute; inset:0; z-index:1100; display:none; align-items:center; justify-content:center; pointer-events:none; }
      #wrongOverlay .msg { background:#111; color:#ff6b6b; border:2px solid #ff6b6b; border-radius:10px; padding:16px 20px; font: bold 36px monospace; letter-spacing:2px; text-shadow:0 0 3px #ff6b6b; }
      #endOverlay { position:absolute; inset:0; z-index:1200; display:none; align-items:center; justify-content:center; background:rgba(0,0,0,0.6); }
      .endBox { background:#111; color:#00ff88; border:2px solid #00ff88; border-radius:10px; padding:18px 22px; width:min(420px, 88vw); text-align:center; box-shadow:0 0 12px rgba(0,0,0,0.5); }
      .endBox h2 { margin:0 0 8px 0; font: bold 22px monospace; letter-spacing:1px; text-shadow:0 0 3px #00ff88; }
      .endScore { margin:6px 0 14px; font: bold 18px monospace; }
      .hsTitle { margin:10px 0 6px; font: bold 16px monospace; letter-spacing:1px; text-shadow:0 0 3px #00ff88; }
      .hsList { border:1px solid #00ff88; border-radius:8px; padding:8px; text-align:left; max-height:40vh; overflow:auto; }
      .hsRow { display:flex; justify-content:space-between; gap:10px; padding:4px 2px; font: 13px monospace; }
      .hsRow + .hsRow { border-top:1px dashed rgba(0,255,136,0.25); }
      .hsIdx { width:22px; opacity:0.9; }
      .hsName { flex:1; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; }
      .hsScore { width:70px; text-align:right; }
      .hsEntry { display:none; margin-top:10px; }
      .hsEntry input { background:#111; color:#00ff88; border:2px solid #00ff88; border-radius:6px; padding:8px 10px; font: bold 13px monospace; letter-spacing:1px; margin-right:8px; width:60%; }
      #splashOverlay { position:absolute; inset:0; z-index:1200; display:none; align-items:center; justify-content:center; background:rgba(0,0,0,0.6); }
      .splashBox { background:#111; color:#00ff88; border:2px solid #00ff88; border-radius:10px; padding:18px 20px; width:min(520px, 90vw); box-shadow:0 0 12px rgba(0,0,0,0.5); }
      .splashTitle { font: bold 20px monospace; letter-spacing:1px; text-shadow:0 0 3px #00ff88; text-align:center; margin-bottom:10px; }
      .splashText { font: bold 14px monospace; letter-spacing:1px; text-shadow:0 0 2px #00ff88; margin-bottom:10px; }
      .splashList { margin:0 0 12px 18px; padding:0; }
      .splashList li { margin:6px 0; font: 13px monospace; }
    </style>
  </head>
  <body>
    <div id="map"></div>
    <div class="hud" id="build">Build: …</div>
    <div class="topbar">
      <button class="btn" id="nyRunde">Ny runde</button>
    </div>
    <div class="scorebar"><div class="timer" id="timer">TIME 00:00</div><div class="score" id="score">SCORE 01000</div></div>
    <div id="hint" style="display:none"></div>
    <div id="guessBar"><div id="choices"></div></div>
    <div id="winOverlay"><div class="winContent"><div>VINNER</div><button id="startNytt" class="btn">Start på nytt</button></div></div>
    <div id="correctOverlay"><div class="msg">KORREKT</div></div>
    <div id="wrongOverlay"><div class="msg">FEIL</div></div>
    <div id="endOverlay">
      <div class="endBox">
        <h2>Tiden er ute!</h2>
        <div class="endScore">Din score: <span id="endScoreVal">00000</span></div>
        <div class="hsTitle">Hi-score</div>
        <div id="hsList" class="hsList"></div>
        <div class="hsEntry" id="hsEntry">
          <input id="hsName" type="text" placeholder="Ditt navn" maxlength="24" />
          <button id="hsSave" class="choiceBtn">Lagre</button>
        </div>
        <div style="display:flex; justify-content:center; gap:10px;">
          <button id="endRestart" class="choiceBtn">START NYTT SPILL</button>
        </div>
      </div>
    </div>
    <div id="splashOverlay">
      <div class="splashBox">
        <div class="splashTitle">Det Store Nasjonalparkspillet</div>
        <div class="splashText">Hvor mange nasjonalparker klarer du å gjette på to minutter?</div>
        <ul class="splashList">
          <li>Du får poeng ut fra hvor mange forsøk du bruker.</li>
          <li>Du får et nytt hint om parken for hvert forsøk du bruker.</li>
          <li>Når du har gjettet riktig går vi videre til neste park.</li>
        </ul>
        <div class="hsTitle">Hi-score</div>
        <div id="hsListSplash" class="hsList" style="margin-bottom:10px;"></div>
        <div style="display:flex; justify-content:center;">
          <button id="startGameBtn" class="choiceBtn">START NYTT SPILL</button>
        </div>
      </div>
    </div>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@turf/turf@6/turf.min.js" crossorigin="anonymous"></script>
    <script>
      (async () => {
        const map = L.map('map', { zoomControl: false, preferCanvas:true });
        const norwayStyle = { color:'#111', weight:1.2, fill:false };
        const parkStyle = { color:'#0a7a62', weight:1.0, fill:true, fillColor:'#cfeee1', fillOpacity:0.35 };
        const selectedStyle = { color:'#00ff88', weight:2, fill:true, fillColor:'#0a7a62', fillOpacity:0.5 };
        const norwayLayer = L.geoJSON(null, { style: norwayStyle }).addTo(map);
        const parksLayer = L.geoJSON(null, { style: parkStyle }).addTo(map);
        const focusLayer = L.geoJSON(null, { style: selectedStyle }).addTo(map);
        const hintEl = document.getElementById('hint');
        const scoreEl = document.getElementById('score');
        const winOverlay = document.getElementById('winOverlay');
        const startNyttBtn = document.getElementById('startNytt');
        const correctOverlay = document.getElementById('correctOverlay');
        const wrongOverlay = document.getElementById('wrongOverlay');
        const timerEl = document.getElementById('timer');
        const endOverlay = document.getElementById('endOverlay');
        const endScoreVal = document.getElementById('endScoreVal');
        const endRestartBtn = document.getElementById('endRestart');
        /* hi-score elementer fjernet */
        const splashOverlay = document.getElementById('splashOverlay');
        const startGameBtn = document.getElementById('startGameBtn');

        // Build badge
        try {
          const b = await fetch('build_version.json?ts=' + Date.now());
          if (b.ok) { const v = await b.json(); const el = document.getElementById('build'); if (el && v && v.build) el.textContent = 'Build: ' + v.build; }
        } catch {}

        // Load outline and db
        const [gjRes, dbRes, hintsRes] = await Promise.all([
          fetch('norway_outline_full.json?ts=' + Date.now()),
          fetch('np_database.json?ts=' + Date.now()),
          fetch('park_hints.json?ts=' + Date.now())
        ]);
        if (!gjRes.ok) throw new Error('Klarte ikke å hente norway_outline_full.json');
        if (!dbRes.ok) throw new Error('Klarte ikke å hente np_database.json');
        const outline = await gjRes.json();
        const db = await dbRes.json();
        const hintsData = hintsRes.ok ? await hintsRes.json() : { parks: {} };
        // Score (retro)
        let score = 0;
        function renderScore(){
          try { scoreEl.textContent = 'SCORE ' + String(Math.max(0, Math.floor(score))).padStart(5, '0'); } catch {}
        }
        renderScore();
        // Timer (nedtelling 2:00)
        let countdownHandle = null; let countdownEndAtMs = 0; let gameOver = false;
        function formatTime(ms){ const t=Math.max(0, Math.floor(ms/1000)); const mm=String(Math.floor(t/60)).padStart(2,'0'); const ss=String(t%60).padStart(2,'0'); return mm+':'+ss; }
        function updateCountdown(){
          const remain = countdownEndAtMs - Date.now();
          if (timerEl) timerEl.textContent = 'TIME ' + formatTime(remain);
          if (remain <= 0){ stopCountdown(); endGame(); }
        }
        function startCountdown(totalMs){ stopCountdown(); countdownEndAtMs = Date.now() + totalMs; updateCountdown(); countdownHandle = setInterval(updateCountdown, 250); }
        function stopCountdown(){ if (countdownHandle) { clearInterval(countdownHandle); countdownHandle = null; } }
        let highscoreSaved = false; let lastFinalScore = 0;
        async function endGame(){
          if (gameOver) return; gameOver = true;
          const sc = Math.max(0, Math.floor(score));
          lastFinalScore = sc; highscoreSaved = false;
          if (endScoreVal) endScoreVal.textContent = String(sc).padStart(5,'0');
          if (endOverlay) endOverlay.style.display = 'flex';
        }

        // Highscores
        /* hi-score fjernet */

        norwayLayer.addData(outline);
        try { map.fitBounds(norwayLayer.getBounds().pad(0.05)); } catch { map.setView([64.5, 16], 4); }

        const feats = (db && db.dataset && Array.isArray(db.dataset.features)) ? db.dataset.features : [];
        const parks = feats.filter(f => f && f.geometry && f.properties && f.properties.source==='park' && f.properties.status!=='deleted' && f.properties.display !== 'no');

        function normalizeKey(p) {
          const code = p && p.code; const name = p && p.name;
          return String(code || name || '').toLowerCase().replace(/[^a-z0-9æøå]/g,'');
        }

        // Build merged features per park
        const groups = new Map();
        for (const f of parks) {
          const key = normalizeKey(f.properties);
          if (!groups.has(key)) groups.set(key, []);
          groups.get(key).push(f);
        }
        const merged = [];
        for (const [key, arr] of groups.entries()) {
          const polys = []; const rep = arr[0].properties || {};
          for (const g of arr) {
            const geom = g.geometry; if (!geom) continue;
            if (geom.type === 'Polygon') polys.push(geom.coordinates);
            else if (geom.type === 'MultiPolygon') polys.push(...geom.coordinates);
          }
          if (!polys.length) continue;
          const geom = polys.length===1 ? { type:'Polygon', coordinates: polys[0] } : { type:'MultiPolygon', coordinates: polys };
          merged.push({ type:'Feature', properties:{ name: rep.name, code: rep.code, key }, geometry: geom });
        }
        parksLayer.addData({ type:'FeatureCollection', features: merged });

        // Hjelpere for flervalg
        function cleanParkName(name){
          const s = String(name || '').trim();
          if (!s) return s;
          const slash = s.indexOf('/');
          if (slash > -1) return s.slice(0, slash).trim();
          return s;
        }
        function labelForPark(p){ const name = (p && p.name) || ''; return cleanParkName(name); }
        function shuffle(arr){ for (let i=arr.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [arr[i],arr[j]]=[arr[j],arr[i]]; } return arr; }
        function pickOtherParks(excludeKey, count){
          const pool = merged.filter(f => f.properties && f.properties.key !== excludeKey);
          const out = [];
          const seen = new Set();
          while (out.length < Math.min(count, pool.length)){
            const cand = pool[Math.floor(Math.random()*pool.length)];
            const k = cand.properties && cand.properties.key;
            if (k && !seen.has(k)) { seen.add(k); out.push(cand); }
          }
          return out;
        }
        let wrongAttemptsInRound = 0;
        function renderChoicesForCurrent(){
          const container = document.getElementById('choices');
          if (!current || !container) return;
          const correctKey = current.properties.key;
          const opts = [current, ...pickOtherParks(correctKey, 5)].slice(0,6);
          const shuffled = shuffle(opts.slice());
          container.innerHTML = shuffled.map(p => `<button class="choiceBtn" data-key="${p.properties.key}">${labelForPark(p.properties)}</button>`).join('');
          container.querySelectorAll('.choiceBtn').forEach(btn => {
            btn.addEventListener('click', ()=>{
              if (gameOver) return;
              const k = btn.getAttribute('data-key');
              if (k === correctKey){
                btn.classList.add('correct');
                // Beregn poeng: 60 minus 10 per feilforsøk, min 10
                const gained = Math.max(10, 60 - 10*wrongAttemptsInRound);
                score += gained; renderScore();
                if (correctOverlay) {
                  const name = cleanParkName(current && current.properties && current.properties.name || '');
                  const box = correctOverlay.querySelector('.msg');
                  if (box) box.innerHTML = `KORREKT<div class="sub">${name}</div>`;
                  correctOverlay.style.display = 'flex';
                  setTimeout(()=>{ correctOverlay.style.display = 'none'; startRound(); }, 1000);
                } else {
                  setTimeout(()=>{ startRound(); }, 1000);
                }
              } else {
                btn.classList.add('wrong');
                btn.disabled = true; btn.classList.add('disabled');
                wrongAttemptsInRound += 1;
                if (wrongOverlay) {
                  wrongOverlay.style.display = 'flex';
                  setTimeout(()=>{
                    wrongOverlay.style.display = 'none';
                    if (hintIndex < currentHints.length-1) { hintIndex += 1; showHint(hintIndex); }
                  }, 1000);
                } else {
                  if (hintIndex < currentHints.length-1) { hintIndex += 1; showHint(hintIndex); }
                }
              }
            });
          });
        }

        function pickRandomPark() {
          if (!merged.length) return null;
          const idx = Math.floor(Math.random() * merged.length);
          return merged[idx];
        }

        function getHintsFor(p) {
          const parks = (hintsData && hintsData.parks) || {};
          const code = String((p && p.code) || '').trim();
          const name = String((p && p.name) || '').trim().toLowerCase();
          let entry = null;
          if (code) {
            for (const k of Object.keys(parks)) { const v = parks[k]; if (String(v && v.code || '').trim() === code) { entry = v; break; } }
          }
          if (!entry && name) {
            entry = parks[name] || null;
            if (!entry) {
              for (const k of Object.keys(parks)) { const v = parks[k]; const vn = String(v && v.name || '').trim().toLowerCase(); if (vn && vn === name) { entry = v; break; } }
            }
          }
          const list = (entry && Array.isArray(entry.hints)) ? entry.hints : [];
          return list;
        }

        function normalizeText(s) {
          try {
            return String(s || '')
              .toLowerCase()
              .normalize('NFD').replace(/[\u0300-\u036f]/g,'')
              .replace(/[æÆ]/g,'ae').replace(/[øØ]/g,'o').replace(/[åÅ]/g,'a')
              .replace(/[^a-z0-9\(\)\-\s]/g,'')
              .trim();
          } catch { return String(s || '').toLowerCase().trim(); }
        }

        let current = null;
        let currentHints = [];
        let hintIndex = 0;
        let revealedHints = [];

        function showHint(idx){
          if (!currentHints.length) { hintEl.style.display='none'; hintEl.innerHTML=''; return; }
          const i = Math.min(idx, currentHints.length-1);
          revealedHints = currentHints.slice(0, i+1);
          // Siste hint øverst
          const items = revealedHints.slice().reverse().map((t, n) => `<div class="hintItem">${t}</div>`).join('');
          hintEl.innerHTML = items;
          hintEl.style.display = 'block';
        }

        async function startRound() {
          focusLayer.clearLayers();
          hintEl.style.display = 'none'; hintEl.innerHTML = '';
          revealedHints = [];
          if (winOverlay) winOverlay.style.display = 'none';
          if (correctOverlay) correctOverlay.style.display = 'none';
          if (wrongOverlay) wrongOverlay.style.display = 'none';
          if (splashOverlay) splashOverlay.style.display = 'none';
          wrongAttemptsInRound = 0;
          const park = pickRandomPark();
          if (!park) return;
          current = park;
          currentHints = getHintsFor(park.properties) || [];
          hintIndex = 0;
          focusLayer.addData(park);
          // Ikke start ny timer her – nedtellingen gjelder hele spillet
          // Zoom så parken tar ca 50% av høyden: bruk padding rundt bounds
          try {
            const b = focusLayer.getBounds();
            const padded = L.latLngBounds(
              [ b.getSouth() - (b.getNorth()-b.getSouth())*0.5, b.getWest() - (b.getEast()-b.getWest())*0.5 ],
              [ b.getNorth() + (b.getNorth()-b.getSouth())*0.5, b.getEast() + (b.getEast()-b.getWest())*0.5 ]
            );
            map.fitBounds(padded, { animate: true });
          } catch {}
          if (currentHints.length) { showHint(0); }
          // Bygg flervalg
          renderChoicesForCurrent();
        }

        document.getElementById('nyRunde').addEventListener('click', startRound);

        if (startNyttBtn) startNyttBtn.addEventListener('click', ()=>{
          winOverlay.style.display = 'none';
          startRound();
        });

        // Splash ved oppstart
        function showSplash(){ if (splashOverlay) splashOverlay.style.display = 'flex'; }
        if (startGameBtn) startGameBtn.addEventListener('click', ()=>{
          if (splashOverlay) splashOverlay.style.display = 'none';
          if (endOverlay) endOverlay.style.display = 'none';
          score = 0; renderScore(); gameOver = false;
          startCountdown(120000);
          startRound();
        });
        if (endRestartBtn) endRestartBtn.addEventListener('click', ()=>{
          if (endOverlay) endOverlay.style.display = 'none';
          showSplash();
        });
        showSplash();
      })().catch(e => {
        const el = document.createElement('div');
        el.className = 'hud'; el.textContent = 'Feil: ' + (e && e.message || e);
        document.body.appendChild(el);
        console.error(e);
      });
    </script>
  </body>
  </html>


